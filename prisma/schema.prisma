datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                   String                @id @default(cuid())
  name                 String?
  email                String?               @unique
  phone                String?
  passwordHash         String?
  role                 String                @default("EMPLOYEE")
  gender               String?
  birthDate            DateTime?
  status               String                @default("APPROVED") // PENDING, APPROVED, REJECTED
  hourlyRate           Float? // Labor cost per hour
  isVerified           Boolean               @default(false)
  verificationCode     String?
  codeExpiresAt        DateTime?
  resetToken           String?
  resetTokenExpiresAt  DateTime?
  permissions          String?               @default("{}") // JSON string of module permissions
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  accounts             Account[]
  sessions             Session[]
  timeEntries          TimeEntry[]
  assignedJobs         Job[]                 @relation("AssignedJobs")
  createdJobs          Job[]                 @relation("CreatedJobs")
  jobAssignments       JobAssignment[]
  jobActivities        JobActivity[]
  inventoryAdjustments InventoryAdjustment[]
  materialRequests     MaterialRequest[]
  jobExpenses          JobExpense[]
  /// QC inspections performed by this manager/admin
  qcRecords            QCRecord[]
  /// Rework entries where this user was identified as responsible
  reworkResponsibleFor ReworkEntry[]         @relation("ReworkResponsible")
  /// Rework entries created/logged by this user (QC/admin)
  reworkCreated        ReworkEntry[]         @relation("ReworkCreatedBy")
  notifications        Notification[]
  manualFolders        ManualFolder[]
  manualFiles          ManualFile[]
  operationsCommonFolders OperationsCommonFolder[]
  operationsCommonFiles   OperationsCommonFile[]
  sopDocuments         SOPDocument[]
  sopTemplates         SOPTemplate[]
  ocrExtractionSuccesses OCRExtractionSuccess[]
  ocrCorrections       OCRCorrection[]
  ocrFormatDetections  OCRFormatDetection[]
  pushTokens           PushToken[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model TimeEntry {
  id            String    @id @default(cuid())
  userId        String
  jobId         String?
  clockIn       DateTime
  clockOut      DateTime?
  breakStart    DateTime?
  breakEnd      DateTime?
  durationHours Float? // Computed on clock out for efficiency metrics
  isRework      Boolean   @default(false)
  clockInNotes  String? // Description entered at Clock In
  notes         String? // Description entered at Clock Out
  images        String? // JSON array of image paths
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  job           Job?      @relation(fields: [jobId], references: [id], onDelete: SetNull)
}

model Customer {
  id         String      @id @default(cuid())
  name       String
  phone      String?
  email      String?
  company    String?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  jobs       Job[]
  invoices   Invoice[]
  quotations Quotation[]
}

model Job {
  id               String            @id @default(cuid())
  title            String
  description      String?
  /// Status lifecycle:
  /// - NOT_STARTED: job created but no one has worked on it yet
  /// - IN_PROGRESS: at least one active or recent TimeEntry
  /// - AWAITING_QC: work appears done and waiting for manager/admin QC
  /// - REWORK: job failed QC and is back with the shop floor
  /// - COMPLETED: passed QC (or minor issues) and is considered done
  /// - CANCELLED: job cancelled
  status           String            @default("NOT_STARTED")
  priority         String            @default("MEDIUM")
  assignedTo       String?
  createdBy        String
  customerId       String?
  pricingType      String            @default("FIXED") // FIXED or T&M (Time & Materials)
  estimatedPrice   Float? // Quoted/estimated price
  finalPrice       Float? // Final agreed price
  estimatedHours   Float? // Planned hours for efficiency calculations
  dueDate          DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  assignee         User?             @relation("AssignedJobs", fields: [assignedTo], references: [id], onDelete: SetNull)
  creator          User              @relation("CreatedJobs", fields: [createdBy], references: [id], onDelete: Cascade)
  customer         Customer?         @relation(fields: [customerId], references: [id], onDelete: SetNull)
  timeEntries      TimeEntry[]
  activities       JobActivity[]
  materialRequests MaterialRequest[]
  expenses         JobExpense[]
  invoices         Invoice[]
  quotations       Quotation[]
  qcRecords        QCRecord[]
  reworkEntries    ReworkEntry[]
  assignments      JobAssignment[]
}

model JobAssignment {
  id        String   @id @default(cuid())
  jobId     String
  userId    String
  createdAt DateTime @default(now())
  job       Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([jobId, userId])
  @@index([jobId])
  @@index([userId])
}

model JobActivity {
  id          String   @id @default(cuid())
  jobId       String
  userId      String
  type        String // "TIME_ENTRY" or "UPDATE"
  timeEntryId String? // Link to time entry if type is TIME_ENTRY
  notes       String?
  images      String? // JSON array of image paths
  createdAt   DateTime @default(now())
  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model InventoryItem {
  id            String                @id @default(cuid())
  name          String
  sku           String?               @unique
  description   String?
  category      String?
  quantity      Int                   @default(0)
  unit          String                @default("pcs") // pcs, kg, lbs, etc.
  minStockLevel Int                   @default(0)
  location      String?
  supplier      String?
  costPerUnit   Float?
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  adjustments   InventoryAdjustment[]
}

model InventoryAdjustment {
  id             String        @id @default(cuid())
  itemId         String
  userId         String
  quantityChange Int // Positive for additions, negative for reductions
  reason         String?
  notes          String?
  createdAt      DateTime      @default(now())
  item           InventoryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model MaterialRequest {
  id                String    @id @default(cuid())
  requestNumber     String?   @unique // Auto-generated: MR0001, MR0002, etc.
  jobId             String?
  userId            String
  itemName          String
  quantity          Int
  unit              String
  description       String?
  priority          String    @default("MEDIUM") // LOW, MEDIUM, HIGH, URGENT
  status            String    @default("PENDING") // PENDING, APPROVED, REJECTED, FULFILLED, ON_HOLD
  amount            Float? // Cost/amount for the material request - required before status update
  requestedDate     DateTime  @default(now())
  fulfilledDate     DateTime?
  dateDelivered     DateTime?
  notes             String?
  recommendedAction String? // APPROVE, PARTIAL, REJECTED - set by admin/manager
  orderStatus       String? // TO_ORDER, ORDERED, RECEIVED - set by admin/manager
  job               Job?      @relation(fields: [jobId], references: [id], onDelete: SetNull)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CompanySettings {
  id          String   @id @default(cuid())
  companyName String
  address     String?
  city        String?
  state       String?
  zipCode     String?
  phone       String?
  email       String?
  website     String?
  logoUrl     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model JobExpense {
  id          String   @id @default(cuid())
  jobId       String
  userId      String // Who recorded the expense
  category    String // Materials, Equipment, Subcontractor, Other
  description String
  amount      Float
  quantity    Float    @default(1)
  unit        String? // pcs, hours, lbs, etc.
  receiptUrl  String? // Path to receipt image
  notes       String?
  expenseDate DateTime @default(now())
  createdAt   DateTime @default(now())
  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// Quality Control record for a job.
/// QC is always performed by a manager or admin.
model QCRecord {
  id        String   @id @default(cuid())
  jobId     String
  qcUserId  String
  /// PASS | FAIL | MINOR_ISSUES
  qcStatus  String
  /// 1.0 for PASS, 0.5 for MINOR_ISSUES, 0.0 for FAIL
  qcScore   Float
  notes     String?
  /// JSON array of photo URLs, consistent with other image fields
  photos    String?
  createdAt DateTime @default(now())

  job    Job  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  qcUser User @relation(fields: [qcUserId], references: [id], onDelete: Cascade)
}

/// Rework entry created when a job fails QC.
/// Tracks who was responsible and how often rework happens.
model ReworkEntry {
  id                String   @id @default(cuid())
  jobId             String
  responsibleUserId String?
  createdByUserId   String
  reason            String
  createdAt         DateTime @default(now())

  job             Job   @relation(fields: [jobId], references: [id], onDelete: Cascade)
  responsibleUser User? @relation("ReworkResponsible", fields: [responsibleUserId], references: [id], onDelete: SetNull)
  createdBy       User  @relation("ReworkCreatedBy", fields: [createdByUserId], references: [id], onDelete: Cascade)
}

model Invoice {
  id             String        @id @default(cuid())
  invoiceNumber  String?       @unique // Auto-generated: INV-YYYY-####, e.g., INV-2025-0001
  jobId          String?
  customerId     String?
  customerName   String?
  customerEmail  String?
  status         String        @default("DRAFT") // DRAFT, SENT, PAID, OVERDUE, VOID
  issueDate      DateTime      @default(now())
  dueDate        DateTime?
  sentDate       DateTime? // When invoice was sent to customer
  releaseDate    DateTime? // When invoice was released/approved
  collectionDate DateTime? // When payment was collected
  creditDate     DateTime? // Credit memo date if applicable
  total          Float         @default(0)
  balance        Float         @default(0)
  notes          String?
  remarks        String? // Admin notes/remarks
  pdfFiles       String? // JSON array of PDF file URLs
  deletedAt      DateTime? // Soft delete - invoice number is preserved to prevent reuse
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  job            Job?          @relation(fields: [jobId], references: [id], onDelete: SetNull)
  customer       Customer?     @relation(fields: [customerId], references: [id], onDelete: SetNull)
  lines          InvoiceLine[]
  payments       Payment[]
}

model InvoiceLine {
  id          String  @id @default(cuid())
  invoiceId   String
  description String
  quantity    Float   @default(1)
  rate        Float   @default(0)
  amount      Float   @default(0)
  invoice     Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
}

model Payment {
  id          String   @id @default(cuid())
  invoiceId   String
  amount      Float
  method      String?
  notes       String?
  paymentDate DateTime @default(now())
  createdAt   DateTime @default(now())
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
}

model Quotation {
  id                   String          @id @default(cuid())
  quotationNumber      String?         @unique // Auto-generated: QUO-2025-0001, etc.
  jobId                String?
  customerId           String?
  customerName         String?
  customerEmail        String?
  customerAddress      String?
  customerPhone        String?
  status               String          @default("DRAFT") // DRAFT, SENT, ACCEPTED, REJECTED, EXPIRED
  issueDate            DateTime        @default(now())
  validUntil           DateTime?
  total                Float           @default(0)
  notes                String?
  paymentBank          String?
  paymentAccountName   String?
  paymentAccountNumber String?
  preparedByName       String?
  preparedByTitle      String?
  shippingFee          Float           @default(0)
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt
  job                  Job?            @relation(fields: [jobId], references: [id], onDelete: SetNull)
  customer             Customer?       @relation(fields: [customerId], references: [id], onDelete: SetNull)
  lines                QuotationLine[]
}

model QuotationLine {
  id          String    @id @default(cuid())
  quotationId String
  description String
  quantity    Float     @default(1)
  rate        Float     @default(0)
  amount      Float     @default(0)
  quotation   Quotation @relation(fields: [quotationId], references: [id], onDelete: Cascade)
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  title     String
  message   String?
  type      String    @default("INFO") // INFO, WARNING, SUCCESS, ERROR, JOB_UPDATE
  isRead    Boolean   @default(false)
  linkUrl   String? // Optional link to navigate when clicked
  createdAt DateTime  @default(now())
  readAt    DateTime?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([userId, createdAt])
}

model ManualFolder {
  id          String       @id @default(cuid())
  name        String
  parentId    String? // For nested folders
  createdBy   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  parent      ManualFolder? @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    ManualFolder[] @relation("FolderHierarchy")
  files       ManualFile[]
  creator     User         @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([parentId])
}

model ManualFile {
  id          String       @id @default(cuid())
  name        String
  originalName String
  fileType    String // pdf, image, word, excel, cad, etc.
  fileSize    Int // Size in bytes
  fileUrl     String // URL to the file (Supabase or other storage)
  folderId    String?
  createdBy   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  folder      ManualFolder? @relation(fields: [folderId], references: [id], onDelete: Cascade)
  creator     User         @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([folderId])
}

model OperationsCommonFolder {
  id          String       @id @default(cuid())
  name        String
  parentId    String? // For nested folders
  createdBy   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  parent      OperationsCommonFolder? @relation("OperationsCommonFolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    OperationsCommonFolder[] @relation("OperationsCommonFolderHierarchy")
  files       OperationsCommonFile[]
  sopDocuments SOPDocument[]
  creator     User         @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([parentId])
}

model OperationsCommonFile {
  id          String       @id @default(cuid())
  name        String
  originalName String
  fileType    String // pdf, image, word, excel, cad, etc.
  fileSize    Int // Size in bytes
  fileUrl     String // URL to the file (Supabase or other storage)
  folderId    String?
  createdBy   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  folder      OperationsCommonFolder? @relation(fields: [folderId], references: [id], onDelete: Cascade)
  creator     User         @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([folderId])
}

// SOP Documents for Operations Common
model SOPDocument {
  id          String       @id @default(cuid())
  title       String
  content     String       @db.Text // HTML content from rich text editor
  folderId    String?
  createdBy   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  folder      OperationsCommonFolder? @relation(fields: [folderId], references: [id], onDelete: Cascade)
  creator     User         @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([folderId])
}

// Templates for SOP Documents
model SOPTemplate {
  id          String       @id @default(cuid())
  name        String
  description String?
  content     String       @db.Text // HTML template content
  createdBy   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  creator     User         @relation(fields: [createdBy], references: [id], onDelete: Cascade)
}

// OCR Learning - Successful Extractions
model OCRExtractionSuccess {
  id              String   @id @default(cuid())
  receiptText     String   @db.Text  // Snippet of OCR text (max 500 chars)
  extractedAmount Float
  storeName       String?
  strategy        String
  linePattern     String   // The line that matched
  formatId        String?
  userId          String
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([storeName])
  @@index([formatId])
  @@index([userId])
}

// OCR Learning - Corrections
model OCRCorrection {
  id                 String   @id @default(cuid())
  receiptText        String   @db.Text  // Snippet of OCR text (max 500 chars)
  originalAmount     Float
  correctedAmount    Float
  correctLinePattern String
  storeName          String?
  strategy           String
  formatId           String?
  userId             String
  createdAt          DateTime @default(now())
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([storeName])
  @@index([formatId])
  @@index([userId])
}

// OCR Learning - Format Detection Results
model OCRFormatDetection {
  id                String   @id @default(cuid())
  detectedStoreName String
  correctStoreName  String
  ocrTextSnippet    String   @db.Text  // Snippet of OCR text (max 500 chars)
  formatId          String?
  wasCorrect        Boolean
  userId            String
  createdAt         DateTime @default(now())
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([detectedStoreName])
  @@index([correctStoreName])
  @@index([userId])
}

// OCR Learning - Aggregated Pattern Stats (computed from above tables)
model OCRPatternStats {
  id           String   @id @default(cuid())
  pattern      String   @unique
  successCount Int      @default(0)
  failureCount Int      @default(0)
  storeName    String?
  formatId     String?
  updatedAt    DateTime @updatedAt
  
  @@index([storeName])
  @@index([formatId])
}

// Push Notification Tokens
model PushToken {
  id        String   @id @default(cuid())
  token     String   @unique
  platform  String   // 'ios' or 'android'
  deviceId  String?
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([platform])
}
